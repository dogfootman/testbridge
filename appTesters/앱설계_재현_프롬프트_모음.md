# 앱 설계 재현 프롬프트 모음

**목적**: 새로운 앱 아이디어가 있을 때, 이 프롬프트를 순서대로 사용하면 기획부터 구현 준비까지 전체 설계 산출물을 만들 수 있습니다.

**사용법**: 각 단계의 프롬프트를 복사하여 Claude에 입력하세요. {앱이름}과 {핵심설명}은 본인 아이디어로 교체하세요. 이전 단계의 산출물이 대화에 있는 상태에서 다음 프롬프트를 입력하세요.

---

## 단계 0. 아이디어 브리핑

> 이 대화에서 {앱이름} 서비스를 기획부터 구현 준비까지 설계할 거야.
>
> **서비스 한 줄 설명**: {핵심설명}
>
> **내가 생각하는 핵심 기능**:
> - {기능1}
> - {기능2}
> - {기능3}
>
> **타겟 사용자**: {누구}
> **수익 모델 아이디어**: {있으면 적고, 없으면 "같이 정해보자"}
> **기술 스택 선호**: {있으면 적고, 없으면 "추천해줘"}
>
> 먼저 이 아이디어에 대해 질문이 있으면 해줘. 방향이 잡히면 단계별로 설계를 진행할 거야.

---

## 단계 1. 서비스 기획안 + 경쟁사 벤치마크

> {앱이름} 서비스 기획안을 작성해줘. 아래 항목을 포함해서 마크다운 파일로 만들어줘.
>
> **서비스 기획안에 포함할 것:**
> 1. 서비스 개요 (문제 정의 → 해결책 → 핵심 가치)
> 2. 타겟 사용자 (페르소나 2~3개, 각각 Pain Point)
> 3. 핵심 기능 목록 (사용자 역할별로 분류)
> 4. 차별점 (기존 서비스 대비)
> 5. 서비스 키워드/슬로건
>
> **경쟁사 벤치마크도 같이:**
> - 직접 경쟁 2~3개, 간접 경쟁 2~3개 조사
> - 각각 모델, 장점, 한계, 우리 차별점
> - 비교 테이블로 정리
>
> 두 내용을 각각 별도 파일로 만들어줘.

---

## 단계 2. 수익 모델 + 가격 정책

> {앱이름}의 수익 모델과 가격 정책을 설계해줘. 마크다운 파일로.
>
> **포함할 것:**
> 1. 수익원 분류 (구독/거래수수료/광고/부가서비스 등에서 적합한 것)
> 2. 플랜 구성 (무료/유료 티어별 기능 차이, 가격)
> 3. 가격 비교표 (테이블)
> 4. 건별/부가 결제 항목 (있다면)
> 5. 예상 수익 시뮬레이션 (사용자 1,000/5,000/10,000명 기준)
> 6. 환불 정책
> 7. 결제 수단 (PG사 선택)
>
> 경쟁사 가격도 참고해서 현실적으로 설정해줘.

---

## 단계 3. 와이어프레임 + 화면 정의서

> {앱이름}의 모든 화면을 정의해줘. 마크다운 파일로.
>
> **포함할 것:**
> 1. 사용자 역할별 화면 목록 (화면ID, 화면명, 접근권한)
> 2. 각 화면의 와이어프레임 (ASCII 아트로)
>    - 레이아웃 구조
>    - 주요 UI 요소 (버튼, 입력, 카드, 탭 등)
>    - 표시 데이터 항목
> 3. 화면별 사용자 액션과 결과
>
> 역할별로 묶어서 정리해줘. 공통 화면(로그인, 마이페이지 등)도 빠짐없이.

---

## 단계 4. 요구사항 정의서

> {앱이름}의 전체 요구사항 정의서를 작성해줘. 마크다운 파일로.
>
> **각 요구사항 항목:**
> - 요구사항 ID (업무코드-기능코드-순번, 예: USR-AUTH-001)
> - 요구사항명
> - 업무분류 (코드)
> - 요구사항 설명 (2~3문장)
> - 우선순위 (P1:MVP 필수, P2:출시 후, P3:향후)
>
> **규칙:**
> - 업무분류별로 그룹핑 (공통, 각 역할별, 결제, 관리자, 비기능 등)
> - 빠짐없이 나열 (인증, 프로필, CRUD, 알림, 결제, 관리자, 비기능 모두)
> - 마지막에 통계 테이블 (업무분류별 P1/P2/P3 건수)
> - MVP 범위 명시
>
> 와이어프레임에서 정의한 화면을 기반으로, 각 화면에서 필요한 기능을 빠짐없이 도출해줘.

---

## 단계 5. 기능 상세 정의서

> 요구사항 정의서의 모든 항목에 대해 기능 상세를 작성해줘.
> 양이 많으면 업무분류별로 파일을 나눠서 만들어줘.
>
> **각 기능 상세에 포함할 것:**
> 1. 입력값 테이블 (항목, 타입, 필수, 제약조건, 설명)
> 2. 출력값 테이블
> 3. 비즈니스 규칙 테이블 (규칙ID, 규칙, 상세)
> 4. 유효성 검증 테이블 (항목, 규칙, 에러메시지)
> 5. 에러 처리 테이블 (에러코드, HTTP, 상황, 메시지, 화면처리)
> 6. 상태 변화 (있는 경우)
> 7. 화면 연결 (시작화면 → 동작 → 이동화면)
> 8. 연관 요구사항
>
> 모든 비즈니스 규칙에 고유 번호(BR-XXX)를 부여해줘.
> 모든 에러 코드도 체계적으로 (접두사-순번).

---

## 단계 6. 비즈니스 프로세스 + 데이터 흐름

> {앱이름}의 핵심 비즈니스 프로세스를 정의하고, 각 프로세스에서 어떤 데이터가 생성/변경/삭제되는지 명세해줘. 마크다운 파일로.
>
> **각 프로세스에 포함할 것:**
> 1. 시퀀스 다이어그램 (텍스트, 관여 액터 간 통신)
> 2. 단계별 데이터 변화 테이블 (단계, 트리거, 조건, 데이터변화 - INSERT/UPDATE/DELETE 구체적으로)
> 3. 생성되는 데이터 엔티티 목록
>
> **마지막에 정리할 것:**
> 1. 전체 데이터 엔티티 목록 (핵심/보조/관리자 분류, ERD 입력용)
> 2. 엔티티 간 관계 (1:N, 1:1, N:M)
> 3. 주요 데이터 흐름 요약 (돈, 포인트, 상태 등 핵심 흐름)
>
> 이 문서가 ERD 설계의 직접적인 입력이 되도록 엔티티와 컬럼을 구체적으로.

---

## 단계 7. 화면 흐름도 (User Flow)

> {앱이름}의 전체 화면 흐름도를 작성해줘. 마크다운 파일로.
>
> **포함할 것:**
> 1. 전체 화면 맵 (텍스트 다이어그램)
> 2. 비로그인 사용자 흐름 (가입 세부 단계 포함)
> 3. 각 역할별 흐름 (메인 네비게이션 + 세부 화면 이동)
>    - 각 화면에서 가능한 액션과 이동 경로
>    - 탭, 모달, 드롭다운 등 UI 상호작용
> 4. 공통 흐름 (마이페이지, 알림, 고객센터)
> 5. 조건별 라우트 가드 (인증/역할/상태별 접근 매트릭스)
> 6. 에러/예외 화면 (404, 500, 403, 네트워크, 점검)
> 7. 딥링크/알림→화면 매핑 (알림 클릭 시 이동 경로 + 라우트)
>
> 와이어프레임의 모든 화면이 흐름도에 연결되어 있는지 확인해줘.

---

## 단계 8. ERD (데이터베이스 설계)

> 비즈니스 프로세스에서 도출한 엔티티 목록을 기반으로 ERD를 설계해줘. 마크다운 파일로.
>
> **각 테이블에 포함할 것:**
> 1. CREATE TABLE SQL (PostgreSQL)
>    - 모든 컬럼: 타입, NOT NULL, DEFAULT, CHECK
>    - PK, FK, UNIQUE 제약
> 2. 인덱스 (일반 + Partial + 복합)
> 3. 테이블 설명 코멘트
>
> **추가로 포함할 것:**
> 1. Mermaid ER 다이어그램
> 2. 인덱스 전략 요약 (복합/Partial 목적)
> 3. 스케줄러/배치 대상 테이블 (스케줄러명, 주기, 동작)
> 4. 마이그레이션 순서 (FK 의존성 기반)
> 5. 초기 시드 데이터
> 6. 통계 (테이블/유니크/FK/인덱스 수)
>
> 양이 많으면 파일을 나눠줘. 설계 원칙(PK규칙, 시간컬럼, Enum방식, 네이밍 등)도 명시해줘.

---

## 단계 9. API 설계

> 기능 상세 정의서의 모든 기능에 대한 RESTful API를 설계해줘. 마크다운 파일로.
>
> **공통 규칙 먼저 정의:**
> - Base URL, 인증 방식, 응답 형식, 에러 형식, 페이지네이션 규칙, HTTP 상태 코드
>
> **각 엔드포인트에 포함할 것:**
> - HTTP 메서드 + 경로
> - 설명 (한 줄)
> - 요청 형식 (JSON 예시, multipart 시 명시)
> - 응답 형식 (JSON 예시, 주요 필드)
> - 에러 응답 (코드, 상황)
>
> **규칙:**
> - 도메인별로 그룹핑 (인증, 각 역할, 결제, CS, 관리자)
> - 마지막에 엔드포인트 총정리 테이블 (도메인, 수, 주요 엔드포인트)
> - 양이 많으면 파일 분할
>
> 실제 프론트에서 호출하는 것처럼 구체적인 JSON으로 써줘.

---

## 단계 10. 구현 준비 문서

> 이제 실제 구현에 들어갈 수 있도록 구현 준비 문서를 만들어줘. 아래 6가지를 모두 포함해서.
>
> **① Prisma 스키마 (schema.prisma 파일)**
> - ERD의 모든 테이블을 Prisma 모델로 변환
> - 모든 관계(relation), 인덱스(@@index), 유니크(@@unique)
> - 모든 Enum 정의
> - snake_case 매핑 (@map)
>
> **② 프로젝트 폴더 구조**
> - 모노레포 구조 (백엔드 + 프론트엔드 + 공유 패키지)
> - 백엔드: 모듈별 controller/service/dto 구조
> - 프론트: App Router 페이지 + 컴포넌트 구조
> - 파일 트리를 상세하게
>
> **③ 환경변수 목록**
> - 백엔드 .env (DB, Redis, OAuth, PG, AWS, JWT, 암호화 등)
> - 프론트 .env (API URL, 클라이언트 키)
> - docker-compose.yml (로컬 개발)
>
> **④ Enum/상수 통합 정의**
> - 비즈니스 상수 (플랜 한도, 가격, 수수료 등) TypeScript 코드로
> - 전체 Enum 목록 통합 테이블
>
> **⑤ 프론트엔드 컴포넌트 구조**
> - 공통/레이아웃/역할별 컴포넌트 목록
> - 각 Props, 사용 화면
>
> **⑥ 구현 가이드 (Phase별 지시서)**
> - Phase 0~N으로 나눠서 구현 순서 정의
> - 각 Phase에서 만들 백엔드 모듈, 프론트 화면, 테스트 항목
> - Claude Code에 복사해서 쓸 수 있는 프롬프트 예시
> - 예상 기간

---

## 보너스. 통합 문서 생성

> 지금까지 만든 모든 산출물을 하나의 Word 문서(.docx)로 통합해줘.
>
> **구성:**
> - 표지 (프로젝트명, 버전, 날짜, 핵심 수치)
> - 목차 (자동 생성)
> - Chapter별로 각 단계의 핵심 내용 요약
> - 기술 스택 + 인프라 정리
> - 산출물 전체 목록
>
> 상세 내용은 개별 .md 파일에 있으니, 통합 문서는 요약본으로 만들어줘.
> 전문적인 포맷 (헤더/푸터, 페이지번호, 색상 테이블)으로 만들어줘.

---

# 사용 팁

## 1. 대화가 길어질 때
대화가 너무 길어지면 컨텍스트가 끊길 수 있습니다. 이전 단계의 핵심 파일을 첨부하면서 다음 단계를 진행하세요.

```
[이전 단계에서 만든 파일 첨부]
이 설계를 기반으로 다음 단계를 진행해줘.
```

## 2. 수정이 필요할 때
```
{파일명}에서 {항목}을 수정해줘.
- 변경 전: {현재 내용}
- 변경 후: {원하는 내용}
- 이유: {왜}

관련된 다른 파일도 같이 수정해줘.
```

## 3. 빠진 게 있는지 확인할 때
```
지금까지 만든 산출물에서 실제 구현할 때 막힐 수 있는 부분이 있는지 검토해줘.
빠진 항목이 있으면 목록으로 알려주고, 하나씩 보완하자.
```

## 4. 기술 스택이 다를 때
프롬프트에서 기술 스택을 명시하면 됩니다:
```
기술 스택:
- 백엔드: Django + Python (NestJS 대신)
- 프론트: React + Vite (Next.js 대신)  
- DB: MySQL (PostgreSQL 대신)
- ORM: SQLAlchemy (Prisma 대신)
이 스택에 맞게 설계해줘.
```

## 5. 모바일 앱일 때
```
이 서비스는 웹이 아니라 모바일 앱(React Native / Flutter)이야.
화면 설계를 모바일 기준으로, API는 동일하게, 
프론트 구조만 모바일 프레임워크에 맞게 변경해줘.
```

---

# 전체 프로세스 요약

```
단계 0. 아이디어 브리핑          → 방향 확정
단계 1. 서비스 기획 + 경쟁사      → 뭘 만들 것인가
단계 2. 수익 모델 + 가격          → 어떻게 돈을 벌 것인가
단계 3. 와이어프레임              → 어떻게 생겼는가
단계 4. 요구사항 정의             → 뭘 해야 하는가 (목록)
단계 5. 기능 상세 정의            → 어떻게 해야 하는가 (상세)
단계 6. 비즈니스 프로세스          → 어떤 순서로 흐르는가
단계 7. 화면 흐름도               → 사용자가 어떻게 이동하는가
단계 8. ERD                      → 데이터를 어떻게 저장하는가
단계 9. API 설계                 → 프론트/백이 어떻게 대화하는가
단계 10. 구현 준비               → 바로 코딩 시작할 수 있게
보너스. 통합 문서                 → 한눈에 보는 전체 설계
```

각 단계에서 이전 단계 산출물을 참조하므로, 순서를 지키는 것이 중요합니다.
